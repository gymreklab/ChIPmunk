\documentclass[12pt]{article}

% Imports
\usepackage{hyperref}
\usepackage[margin=0.5in]{geometry}
\usepackage{ctable}
\usepackage{array}
\usepackage{titlesec}
\usepackage{amsmath}

% Paragraph spacing
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

% Default font
\renewcommand*{\familydefault}{\sfdefault}

% title spacing
\titlespacing*{\section}
{0pt}{2pt}{0pt}
\titlespacing*{\subsection}
{0pt}{2pt}{0pt}

% table lines
\newcolumntype{?}{!{\vrule width 1pt}}

% hyperlinks
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=red,
  citecolor=red,
 }

\begin{document}

%%% Notes %%%%
% * Put one sentence per line to make github track changes easier
% * Do not hard code references to figures, equations in this doc. use \ref{label} instead
\section*{Online Methods}

\subsection*{ChIPmunk model}

ChIPmunk models each major step (shearing, pulldown, PCR, and sequencing) of the ChIP-seq protocol (\textbf{Figure 1A, steps 1-4}) as a distinct module. It assumes binding sites for the target epitome are known, unlike other tools [refs] which focus on simulating binding sites themselves. Model parameters are summarized in \textbf{Table 1}.

\subsubsection*{1. Shearing}

In step 1, cross-linked DNA is sheared to a target fragment length, typically by sonication.
ChIPmunk models the length distribution of fragments.
We model fragment lengths using a gamma distribution (\textbf{Figure 1B}) based on empirical observation of fragment distributions which have long right tails (\textbf{Supplementary Figure 2}).
In the case of paired-end reads, fragment lengths can be determined trivially from the mapping locations of paired reads.
For single-end reads, individual fragment lengths are not directly observed. We outline a novel method for inferring summary statistics for the length distribution using single-end reads.

\paragraph{Inferring fragment lengths from paired-end reads}
The observed fragment length ($X_i$) for each read pair $i$ can be computed based on the mapping coordinates of the two reads.
The learn module randomly selects 10,000 read pairs from the input BAM for fitting a gamma distribution.
Read pairs are filtered to remove fragments marked as duplicates or secondary alignments. % TODO what about if not proper pair? and not mapping to same chrom?
Read pairs are further filtered to remove fragments with length greater than 3 times the median length of selected fragments.

The mean fragment length is easily computed as $\mu = \dfrac{\sum_{i=1}^{n}X_i}{n}$, where $n$ is the number of fragments remaining after filtering. We then use the method of moments to find maximum likelihood estimates of the gamma distribution shape ($k$) and scale parameters ($\theta$):

\begin{equation}
  k =  \dfrac{\mu}{\theta}
\end{equation}
\begin{equation}
  \theta = \dfrac{1}{n\mu}\sum_{i=1}^{n}(X_i - \mu)^2
\end{equation}

\paragraph{Inferring fragment lengths from single-end reads}
To estimate the fragment length distribution from single-end reads, we assume the length distribution follows gamma distribution with the mean $\mu$ and variance $v$, and use reads located inside ChIP-seq peaks (provided as input) to estimate $\mu$ and $v$ which are used to compute $k$ and $\theta$.

For each peak $peak_i$, we keep track of two lists, $\{start\}_{peak_i}$ and $\{end\}_{peak_i}$.
For each read overlapping $peak_i$, if the read is on the forward strand we add its start coordinate $\{start\}_{peak_i}$.
If the read is on the reverse strand we add its start coordinate to $\{end\}_{peak_i}$.
The center point of this peak is calculated as:

\begin{equation} \label{eq:center}
  center_{peak_i} = \frac{mean(\{start\}_{peak_i}) + mean(\{end\}_{peak_i})}{2}
\end{equation}
  
For every $peak_i$ we offset the coordinates in $\{start\}_{peak_i}$ and $\{end\}_{peak_i}$ by $center_{peak_i}$t, so that the coordinates of start points and end points are normalized and symmetric around zero.
We then concatenate lists from each peak to form $\{start\}$ and $\{end\}$:

\begin{equation} \label{eq:concat}
  \begin{array}{c}
  \{start\} = \oplus_{i=0}^{n} (\{start\}_{peak_i} - center_{peak_i})\\
  \{end\} = \oplus_{i=0}^{n} (\{end\}_{peak_i} - center_{peak_i})
  \end{array}
\end{equation}

The mean value of fragment length mu can be estimated as:
\begin{equation}
  \mu = mean(\{end\}) - mean(\{start\})
\end{equation}

We calculate the probability density functions, cumulative density functions and expected density functions for both $\{start\}$ and $\{end\}$.
The expected density function $EDF(x)$ is defined as the expected deviation of a random element in the list to $x$:
\begin{equation} \label{eq:EDF}
  \begin{array}{c} 
    EDF_{start}(x) = E(|S - x|) \\
    EDF_{end}(x) = E(|E - x|)
    \end{array}
\end{equation}
where $S$ is a random element in $\{start\}$ and $E$ is a random element in $\{end\}$.

Since we can compute $\mu$, we can reduce the density function of the fragment length distribution to $p_v(x)$. % TODO p_v(x) is the PDF. now just function of v and x.
We construct a score function $F(v)$ as shown below.
Intuitively, if we have a correct guess of $v$, $F(v)$ should be equal to zero.

\begin{equation}
  \begin{array}{c} \label{eq:Fv}
F(v) = E_v(|S + \frac{L}{2}|) + E_v(|E - \frac{L}{2}|) - E(|S + \frac{\mu}{2}|) + E(|E- \frac{\mu}{2}|) \\
E_v(|S + L/2|) = \sum_{x=0}^\infty p_v(x) * EDF_{start}(-\frac{x}{2}) \\
E_v(|E - L/2|) = \sum_{x=0}^\infty p_v(x) * EDF_{end}(\frac{x}{2}) \\
E(|S + \frac{\mu}{2}|)=EDF_{start}(x) \\
E(|E - \frac{\mu}{2}|)=EDF_{end}(x) \\
\end{array}
\end{equation}

To find an optimal $v$ that minimizes $|F(v)|$, we conduct a binary search between 1000 and 10,000.

In practice, we slightly offset the last two items in the score function in \textbf{Equation~\ref{eq:Fv}} to get the score below, which gave slightly more accurate estimation of $v$ on real data. This may be due to the fact that fragment length distributions are truncated on the left end, with little or no fragments with lengths less than 100bp observed, and thus do not follow a true gamma distribution.

\begin{equation}
F(v) = E_v(|S + \frac{L}{2}|) + E_v(|E - \frac{L}{2}|) - E(|S + \frac{\mu}{2} - \frac{E- \frac{\mu}{2}}{4}|) - E(|E- \frac{\mu}{2} - \frac{S + \frac{\mu}{2}}{4}|)
\end{equation}

\subsubsection*{Pulldown}
In step 2, sheared cross-linked DNA is subject to pulldown, during which an antibody for the protein or modification of interest is used to enrich the pool of fragments for those bound to the epitope recognized by the antibody.
This process is imperfect: some bound fragments will not be pulled down, and some unbound fragments will be pulled down.
To better model this process, we built the following formula to quantify the probability of pulldown for fragments in peak regions and also fragments in non-peak regions.

We use $B$ to represent if a random fragment is bound, and $\overline{B}$ if unbound. And we use $D$ to denote if a fragment is pulled down.
For any fragment, the probability of being pulled down is:
\begin{equation} \label{eq:pulldown}
    P(D) = P(D, B) + P(D, \overline{B}) = P(D|B)*P(B) + P(D|\overline{B})*P(\overline{B})
\end{equation}

In peak regions, due to the nature of ChIP-sequencing experiments, $P(D, B)$ is much greater than $P(D, \overline{B})$.
Thus, for fragment $i$ overlapped with peak $k$, the equation \textbf{Equation~\ref{eq:pulldown}} reduces to:
\begin{equation} \label{eq:pulldown_peak}
    P_i(D) \approx P_{ik}(D|B)*P_{ik}(B)
\end{equation}
For any fragment $i$, we assume that the probability of its being bound $P_{ik}(B)$ is directly proportional to the peak score $C_k$ with a coefficient $\alpha$, i.e. $P_{ik}(B) = \alpha*C_k$,
and once it is bound, the probability of its being pulled down is 100\%, i.e. $P_{ik}(D|B) = 1$.
Based users' choices, peak scores can either be based on peak intensities given in an input peak BED file or determined based on counts of overlapped fragments if a BAM file is specified.
If peak intensities are given, $C_k$ is defined as the intensity of peak $k$ divided by the maximum peak intensity.
If a BAM file is specified, $C_k$ is defined as the number of fragments overlapping peak $k$ divided by the maximum number of reads overlapping any peak.
This scaling ensures all peak scores are between 0 and 1. Thus for a fragment $i$ overlapped with peak $k$, the probability of its being pulled down is:
\begin{equation} \label{eq:pulldown_peak_in_practice}
P_i(D) \approx \alpha C_k
\end{equation}

For a fragment $j$ in a non-peak region, since the probability of its being bound is extremely small, we set $P_j(B) = 0$ and $P_j(\overline{B}) = 1$ as an approximation.
And we treat them uniformly with the same probability of pull-down, i.e. $P_{j}(D|\overline{B}) = P_{avg}(D|\overline{B})$.
Thus the equation \textbf{Equation~\ref{eq:pulldown}} reduces into:
\begin{equation} \label{eq:pulldown_nonpeak}
    P_j(D) \approx P_{avg}(D|\overline{B})
\end{equation}
To estimate the probability $P_{avg}(D|\overline{B})$, we model the ratio of the probabilities for a bound vs. an unbound fragment to be pulled down. Using Baye's Rule, we have:

\begin{equation} \label{eq:bayesPDB}
    P_{avg}(D|B) = \frac{P_{avg}(B|D)P_{avg}(D)}{P_{avg}(B)}
\end{equation}
\begin{equation} \label{eq:bayesPDUB}
    P_{avg}(D|\overline{B}) = \frac{P_{avg}(\overline{B}|D)P_{avg}(D)}{P_{avg}(\overline{B})}
\end{equation}

Taking the ratio of these cancels $P_{avg}(D)$ and gives:
\begin{equation} \label{eq:ratio}
  R = \frac{P_{avg}(D|B)}{P_{avg}(D|\overline{B})} = \frac{P(B|D)P_{avg}(\overline{B})}{P(\overline{B}|D)P_{avg}(B)}
\end{equation}

$P_{avg}(B)$, or the probability that a fragment is bound on average, is equal to the fraction of the genome bound by the factor of interest $f$.
We can approximate $f$ as the sum of the lengths of all peaks $l_k$ divided by the total length of the genome $T$.
We can approximate $f$ with \textbf{Equation~\ref{eq:avg_b}}, in which $l_k$ denotes the length of peak $k$ and this equation calculates the expected sum length of bound fragments divided by the total length of the genome $T$. Then we have $P(B) \approx f$ and $P(\overline{B}) \approx 1-f$.
\begin{equation} \label{eq:avg_b}
  f \approx \frac{1}{nT} \sum_{k=1}^{n} P_k(B) l_k \approx \frac{\alpha}{nT} \sum_{k=1}^{n} C_k l_k
\end{equation}


$P_{avg}(B|D)$, or the averaged probability that a fragment is bound given that it is pulled down, is a measure of the specificity of the antibody. This can be approximated by analyzing the percent of fragments falling within peaks, which we denote as $s$.
Thus $P_{avg}(B|D) \approx s$ and $P_{avg}(\overline{B}|D) \approx 1-s$.

Using these two metrics, $f$, and $s$ (\textbf{Supplementary Table 1}), we can simplify the ratio $R$ as:
\begin{equation} \label{eq:ratiosimple}
  R = \frac{s(1-f)}{(1-s)f}
\end{equation}

Combining all equations from \textbf{Equation~\ref{eq:pulldown_nonpeak}} to \textbf{Equation~\ref{eq:ratiosimple}} together, we can have the estimation of $P(D)$ for fragments in non-peak regions as is shown below:
\begin{equation} \label{eq:pulldown_nonpeak_in_practice_1}
P_j(D) \approx \frac{(1-s)f}{s(1-f)} * P_{avg}(D|B)
\end{equation}
Since we assume $P(D|B)$ is always equal to 1, \textbf{Equation~\ref{eq:pulldown_nonpeak}} can be further written as:
\begin{equation} \label{eq:pulldown_nonpeak_in_practice_2}
P_j(D) \approx \frac{(1-s)f}{s(1-f)}
\end{equation}

Because $f$ is very small in practice and proportional to the coefficient $\alpha$ in \textbf{Equation~\ref{eq:avg_b}}, $P_j(D)$ is also nearly proportional to $\alpha$ same as $P_i(D)$ of peak regions. Thus, the probability of pull-down is always proportional to $\alpha$ regardless of the fragment location, and we set $\alpha = 1$ in practice.

\subsubsection*{PCR}

In step 3, PCR is used to amplify pulled down fragments before sequencing.
Let $n_i$ represent the number of reads (or read pairs) with $i$ PCR duplicates (including the original fragment).
$n_i$ is modeled using a geometric distribution, where $r$ gives the probability that a fragment has no PCR duplicates.
The parameter $r$ is estimated as $1/\overline{n}$, where $\overline{n} = \frac{\sum_{i=1}^\infty (i * n_i)}{\sum_{i=1}^\infty n_i}$.

\subsubsection*{Sequencing}

In step 4, amplified fragments are subject to sequencing.
Sequences are based on an input reference genome using the coordinates of each fragment.
We model the per-base pair substitution rate, insertion rate, and deletion rate (\textbf{Supplementary Table 1}).

\subsection*{ChIPmunk implementation}

\subsubsection*{Learn implementation}
% user input bam, bed, single vs. paired
% shearing for paired or single
% pulldown learn f or s
% PCR learn r. Require duplicates marked
% output as JSON format
The Learn module requires a BAM file, a peaks file, a prefix name for the output model, and the type of the peaks file.
The BAM file must be sorted, have its duplicates flagged, and be indexed.
The type of the peaks file can be specified as "homer" or "bed" in order to accurately parse through the correct file format.
The module has two options, single and paired end estimation, for learning the shearing fragment length distribution parameters, $k$ and $\theta$.
By default the module chooses single end estimation, however the user can specify if paired end estimation should be used instead.
Single end estimation requires reading through the BAM file and the peaks file to calculate the gamma distribution parameters whereas paired end only requires the BAM file.
Next, the module generates the pulldown parameters, $s$ and $f$.
This requires reading through the peak and BAM file to get the genome length and tagcount which are used to create parameters that determine whether a fragment at a particular location will be pulled down. 
Lastly, the module will create the parameter for PCR rate, $r$. 
The BAM file must be marked for duplicates otherwise this part of the module will fail to give an accurate result because it uses these flags to determine the rate modeled after a geometric distribution.
All of the values generated from this module are outputted to the name and location specified in prefix in a JSON format under the labels: frag, pcr$\_$rate, and pulldown.
"frag" holds $k$ and $\theta$ estimated parameters for shearing.
"pcr$\_$rate" holds $r$, the probability that a fragment will not be copied.
"pulldown" holds the spot and frac scores, $s$ and $f$.

Our learning module models read files, and generates parameters for 
(1) fragment length distribution, (2) pull-down efficiency, (3) PCR efficiency.
To estimate the fragment length distribution of an input read file,
our learning module chooses a modeling function based on the type of the read file (single-end or double-end reads),
and finds the best fit gamma distribution $Gamma (k, \theta)$.
To calculate pull-down efficiency, our learning module takes both the read file and the its peak file as input,
and returns the fraction of the genome bound by the factor of interest $f$ and the SPOT score $s$.
In the estimation of PCR efficiency, we scan through the read file, 
identify unique samples and the numbers of their PCR copies,
and fit them to a geometric distribution $Geo(p)$ with the number of PCR copies (including the original copy)
as x-axis and the number of samples falling into each bin as y-axis.
It’s noteworthy that this estimation step requires a BAM file with PCR copies flagged. Lastly, the learning module summarizes up all parameters, including $k$, $theta$, $f$, $s$ and $p$, and writes them into a json file with a user-specified path prefix.

\subsubsection*{Simulation implementation}
% TODO
% User inputs bed, optional BAM, model params

% Choose num copies. Separate sim per copy. discuss numcopies issue here

% For each copy:
% - Generate fragments, walking along chrom and choosing sizes from gamma distr
% - Decide based on overlap with peak whether to pull down
% - PCR on the pool of frags
% - Sequence

% Analyze one bin at a time for computational efficiency (how choose bin size, how deal with boundaries of bins)
% In practice, need to decide how many reads to generate from each chunk (see Michael's old pulldown text in scratch.tex)

\subsubsection*{C++ implementation details}
% TODO
% C++ implementation
% open source on github
% use standard open source libraries (htslib for BAM reading, pthread for multithreading)
% work with standard file formats (BED, BAM, jSON)
ChIPmunk is implemented using C++, and the its source code is publicly available on Github: https://github.com/gymreklab/ChIPmunk.
As input, it supports the standrad BAM file format, and two BED file formats including HOMER format and ENCODE BED format.

\subsection*{Inferring parameters of ENCODE datasets}

We used the ENCODE Project's REST API to write a Python script to automatically identify available ChIP-sequencing for the GM12878 cell line.
We fetched unfiltered BAM files and narrowPeak or broadPeak peak files for transcription factors and histone modifications, respectively.
If multiple replicates were available for a factor, we chose the first one as a training example.
We chose a total of 221 datasets as examples.

We used the Picard \cite{picard} MarkDuplicates tool with default parameters to mark duplicates in each BAM file.
For paired end datasets, we called ChIPmunk's learn module with non-default parameter -{}-paired.
For single end datasets, we used non-default parameters -c 7 -{}-thres 100 for transcription factors and -c 7 -{}-thres 5 for histone modifications.
For 12 example paired-end datasets, we called learn in both paired end and single end mode to compare inferred fragment length distributions (\textbf{Supplementary Figure 2}).

Inferred parameters as well as links to JSON model files that can be used as input to the ChIPmunk simreads module are provided in \textbf{Supplementary Table 2}.

\bibliography{ChIPmunk_OnlineMethods}
\bibliographystyle{ieeetr}

\end{document}

